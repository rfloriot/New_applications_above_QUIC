// Network mocking system for test suite
// By CLAREMBEAU Alexis & FLORIOT Remi
// 2017-2018 Master's thesis. All rights reserved.

package internal

import (
	"crypto/rand"
	"crypto/rsa"
	"crypto/tls"
	"crypto/x509"
	"encoding/pem"
	"math/big"

	"github.com/lucas-clemente/quic-go"
)

var mockTcpPacket = []byte{
	0x60, 0x0b, 0xec, 0x05, 0x00, 0x20, 0x06, 0x39, 0x2a, 0x00, 0x14, 0x50, 0x40, 0x0e, 0x08, 0x08,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x0d, 0x2a, 0x02, 0x27, 0x88, 0x03, 0xf5, 0xf0, 0xa9,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0xbb, 0xa3, 0xd0, 0x05, 0x80, 0x60, 0xfe,
	0x9b, 0x20, 0x92, 0xc7, 0x80, 0x10, 0x00, 0x6e, 0x17, 0x49, 0x00, 0x00, 0x01, 0x01, 0x08, 0x0a,
	0x35, 0x8f, 0x58, 0x7c, 0xb1, 0xb0, 0xf8, 0xba,
}
var mockTcpPacketFlow = "443->41936"

var mockTcpPacket2 = []byte{
	0x60, 0x07, 0x84, 0x05, 0x00, 0x20, 0x06, 0x40, 0x2a, 0x02, 0x27, 0x88, 0x03, 0xf5, 0xf0, 0xa9,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x2a, 0x02, 0x27, 0x88, 0xff, 0xf0, 0x00, 0x09,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xeb, 0x24, 0x01, 0xbb, 0xc7, 0xc1, 0xef, 0x5d,
	0x0a, 0x73, 0x13, 0x65, 0x80, 0x10, 0x47, 0x8f, 0x97, 0xe7, 0x00, 0x00, 0x01, 0x01, 0x08, 0x0a,
	0x2d, 0xab, 0xa4, 0x06, 0xf4, 0xff, 0xa3, 0x00,
}
var mockTcpPacketFlow2 = "60196->443"

var mockPingPacket = []byte{
	0x45, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x00, 0x35, 0x01, 0x06, 0xd8, 0xac, 0xd9, 0x11, 0x43,
	0xc0, 0xa8, 0x00, 0x0d, 0x00, 0x00, 0x96, 0x1a, 0x1c, 0x3b, 0x00, 0x01, 0x7a, 0x4f, 0x06, 0x5a,
	0x00, 0x00, 0x00, 0x00, 0x02, 0x2d, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x12, 0x13,
	0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,
	0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33,
	0x34, 0x35, 0x36, 0x37,
}
var mockPingPacketFlow = "[]->[]"

// Mock a client-server system (with server connected to client)
func MockClientServer(addr string) (quic.Session, quic.Stream, quic.Session, quic.Stream, error) {
	waitChan := make(chan error)

	var servStream, cliStream quic.Stream
	var servSess, cliSess quic.Session
	var err error

	go func() {
		servSess, servStream, err = MockServer(addr)
		if err != nil {
			waitChan <- err
		}
		waitChan <- nil
	}()
	cliSess, cliStream, err = MockClient(addr)
	if err != nil {
		return nil, nil, nil, nil, err
	}
	err = <-waitChan

	return cliSess, cliStream, servSess, servStream, err
}

func MockServer(addr string) (quic.Session, quic.Stream, error) {
	listener, err := quic.ListenAddr(addr, generateTLSConfig(), nil)
	if err != nil {
		return nil, nil, err
	}
	sess, err := listener.Accept()
	if err != nil {
		return nil, nil, err
	}
	stream, err := sess.AcceptStream()
	if err != nil {
		return nil, nil, err
	}

	recv := make([]byte, 5, 5)
	stream.Read(recv)

	return sess, stream, nil
}

func MockClient(addr string) (quic.Session, quic.Stream, error) {
	session, err := quic.DialAddr(addr, &tls.Config{InsecureSkipVerify: true}, nil)
	if err != nil {
		return nil, nil, err
	}

	stream, err := session.OpenStreamSync()
	if err != nil {
		return nil, nil, err
	}

	stream.Write([]byte("start"))

	return session, stream, nil
}

func generateTLSConfig() *tls.Config {
	key, err := rsa.GenerateKey(rand.Reader, 1024)
	if err != nil {
		panic(err)
	}
	template := x509.Certificate{SerialNumber: big.NewInt(1)}
	certDER, err := x509.CreateCertificate(rand.Reader, &template, &template, &key.PublicKey, key)
	if err != nil {
		panic(err)
	}
	keyPEM := pem.EncodeToMemory(&pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(key)})
	certPEM := pem.EncodeToMemory(&pem.Block{Type: "CERTIFICATE", Bytes: certDER})

	tlsCert, err := tls.X509KeyPair(certPEM, keyPEM)
	if err != nil {
		panic(err)
	}
	return &tls.Config{Certificates: []tls.Certificate{tlsCert}}
}
